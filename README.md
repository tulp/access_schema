# AccessSchema gem - ACL and domain policies for your app

AccessSchema is tool to add ACL and domain policy rules to an application. It is framework/ORM agnostic and provides declarative DSL.

Inspired by [ya_acl](https://github.com/kaize/ya_acl)

```
  gem install access_schema
```

## An example of use with Rails

### Definition

```ruby
  # config/policy.rb

  roles do

    # Tariff plans
    role :none
    role :bulb
    role :flower
    role :bouquet

    # To allow admin violate tariff plan rules
    role :admin
  end

  asserts do

    assert :photo_limit, [:limit] do
      subject.photos_count < limit
    end

    assert :attrs, [:new_attrs, :disallow] do
      # check if any disallowed attributes are changing in subject with new_attrs
    end

    assert :owner, [:user_id] do
      subject.owner.id == user_id
    end

    assert :creator, [:user_id] do
      subject.creator.id == user_id
    end

    assert :city, [:city_id] do
      subject.city.id == city_id
    end

    # autogenerated assert body: subject.assert_name?
    assert :unapproved

  end

  resource "Review" do

    # privileged roles can be specified

    privilege :mark_featured, [:flower, :bouquet]

    privilege :add_photo, [:bouquet] do

      # every pass check result combined with OR
      # to calculate final result of privilege check

      pass [:owner, :photo_limit], [:bulb], :limit => 5
      pass [:owner, :photo_limit], [:flower], :limit => 10

      # checks for every role if role is not specified

      pass [:creator, :photo_limit], :limit => 2
      pass :photo_limit, :limit => 1

    end

    # everyone can read

    privilege :read

  end


  resource "Business" do

    # admin can do everything

    privilege :update, [:admin] do

      # creator can update eny field while business is not approved yet
      pass [:creator, :unapproved]

      # creator can update any filed except name and contacts
      pass [:creator, :attrs], :disallow => [:name, :contacts]

      # owner of business can update any fields
      pass [:owner]
    end

    privilege :bind_owner, [:admin] do

      # account manager can bind owner if the same city passed
      #  policy(actor).require!(@business, :bind_owner,
      #    :manager_city_id => actor.city.id,
      #    :owner_city_id => new_owner.city.id
      #  )

      pass [:account_manager] do |owner_city_id, manager_city_id|
        subject.city.id == owner_city_id == manager_city_id
      end

    end

  end
```

```ruby
  # config/acl.rb
  roles do
    role :none
    role :admin
    role :user
  end

  resource "BusinessController" do

    privilege :index
    privilege :show

    privilege :edit, [:user]
    privilege :update, [:user]

    privilege :new, [:user]
    privilege :create, [:user]

    privilege :destroy, [:admin]

  end
```

### Configuration

```ruby
  #config/initializers/access_schema.rb

  AccessSchema.configure do

    schema :policy, AccessSchema.build_file('config/policy.rb')
    schema :acl, AccessSchema.build_file('config/acl.rb')

    logger Rails.logger

  end

```

### Accessing from Rails application code

Define a helper:

```ruby
  #access_schema_helper.rb

  class AccessSchemaHelper

    # Use ACL in controllers:
    #
    #   before_filter { required! :reviews, :delete }
    #
    # and views
    #
    #   - if can? :reviews, :delete, :subject => review
    #     = link_to "Delete", review_path(review)
    #

    def required!(route_method, action = nil, options = {})

      url_options = send "hash_for_#{route_method}_path"
      resource = "#{url_options[:controller].to_s.camelize}Controller"

      privilege = action || url_options[:action]
      acl.require! resource, privilege, options

    end

    def can?(*args)
      required!(*args)
    rescue AccessSchema::NotAllowed => e
      false
    else
      true
    end

    def acl

      AccessSchema.schema(:acl).with_options({
        roles: current_roles,
        user_id: current_user.try(:id)
      })

    end

    # Use in controllers and views
    # tarifF plans or other domain logic policies
    #
    #   policy.allow? review, :add_photo
    #


    def policy

      # Policy have to check actor roles and subject owner state (tariff plans for example)
      # to evaluate permission. So we pass proc and deal with particular subject to
      # calculate roles.
      #
      roles_calculator = proc do |options|

        plan = options[:subject].try(:owner).try(:plan)
        plan ||= [ current_user.try(:plan) || :none ]
        current_roles | plan

      end

      AccessSchema.schema(:policy).with_options({
        roles: roles_calculator,
        user_id: current_user.try(:id)
      })

    end

  end

```

But there are no current_user method in a Service Layer! So pass an extra option - actor:

```ruby
  #./app/services/base_service.rb
  class BaseService

    def policy(actor)

      roles_calculator = proc do |options|

        plan = options[:subject].try(:owner).try(:plan)
        plan ||= [ actor.try(:plan) || :none ]
        current_roles | plan

      end

      AccessSchema.schema(:policy).with_options({
        roles: roles_calculator,
        user_id: actor.try(:id)
      })
    end

  end

  #./app/services/review_service.rb

  class ReviewService < BaseSevice

    def mark_featured(review_id, actor)

      review = Review.find(review_id)
      policy(actor).require! review, :mark_featured

      review.featured = true
      review.save!

    end

    def update(review_id, attrs, actor)

      review = Review.find(review_id)
      policy(actor).require! review, :edit, :attrs => attrs

      review.update_attributes(attrs)

    end

  end

```

